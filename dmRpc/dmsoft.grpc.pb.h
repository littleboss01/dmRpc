// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: dmsoft.proto
#ifndef GRPC_dmsoft_2eproto__INCLUDED
#define GRPC_dmsoft_2eproto__INCLUDED

#include "dmsoft.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace dmsoftRpc {

class dmPoolService final {
 public:
  static constexpr char const* service_full_name() {
    return "dmsoftRpc.dmPoolService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    class async_interface {
     public:
      virtual ~async_interface() {}
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    class async final :
      public StubInterface::async_interface {
     public:
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
  };
  typedef Service AsyncService;
  typedef Service CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  typedef Service StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef Service StreamedService;
};

class dmsoftService final {
 public:
  static constexpr char const* service_full_name() {
    return "dmsoftRpc.dmsoftService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::GetDmIndexResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::GetDmIndexResponse>> AsyncGetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::GetDmIndexResponse>>(AsyncGetDmIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::GetDmIndexResponse>> PrepareAsyncGetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::GetDmIndexResponse>>(PrepareAsyncGetDmIndexRaw(context, request, cq));
    }
    // 归还dm
    virtual ::grpc::Status ReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncReturnDmIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncReturnDmIndexRaw(context, request, cq));
    }
    virtual ::grpc::Status Ver(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::VerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::VerResponse>> AsyncVer(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::VerResponse>>(AsyncVerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::VerResponse>> PrepareAsyncVer(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::VerResponse>>(PrepareAsyncVerRaw(context, request, cq));
    }
    // long GetCursorPos(x,y)
    virtual ::grpc::Status GetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::PointResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::PointResponse>> AsyncGetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::PointResponse>>(AsyncGetCursorPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::PointResponse>> PrepareAsyncGetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::PointResponse>>(PrepareAsyncGetCursorPosRaw(context, request, cq));
    }
    // long KeyDown(vk_code)
    virtual ::grpc::Status KeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncKeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncKeyDownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncKeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncKeyDownRaw(context, request, cq));
    }
    // long KeyDownChar(key_str)
    virtual ::grpc::Status KeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncKeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncKeyDownCharRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncKeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncKeyDownCharRaw(context, request, cq));
    }
    // long KeyPress(vk_code)
    virtual ::grpc::Status KeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncKeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncKeyPressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncKeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncKeyPressRaw(context, request, cq));
    }
    // long KeyUp(vk_code)
    virtual ::grpc::Status KeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncKeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncKeyUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncKeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncKeyUpRaw(context, request, cq));
    }
    // long LeftClick()
    virtual ::grpc::Status LeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncLeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncLeftClickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLeftClickRaw(context, request, cq));
    }
    // long LeftDoubleClick()
    virtual ::grpc::Status LeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncLeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncLeftDoubleClickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLeftDoubleClickRaw(context, request, cq));
    }
    // long LeftDown()
    virtual ::grpc::Status LeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncLeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncLeftDownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLeftDownRaw(context, request, cq));
    }
    // long LeftUp()
    virtual ::grpc::Status LeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncLeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncLeftUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLeftUpRaw(context, request, cq));
    }
    // long MoveR(rx,ry)
    virtual ::grpc::Status MoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncMoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncMoveRRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncMoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncMoveRRaw(context, request, cq));
    }
    // long MoveTo(x,y)
    virtual ::grpc::Status MoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncMoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncMoveToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncMoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncMoveToRaw(context, request, cq));
    }
    // string MoveToEx(x,y,w,h)
    virtual ::grpc::Status MoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::dmsoftRpc::StringResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>> AsyncMoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>>(AsyncMoveToExRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>> PrepareAsyncMoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>>(PrepareAsyncMoveToExRaw(context, request, cq));
    }
    // long RightClick()
    virtual ::grpc::Status RightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncRightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncRightClickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncRightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncRightClickRaw(context, request, cq));
    }
    // long RightDown()
    virtual ::grpc::Status RightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncRightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncRightDownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncRightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncRightDownRaw(context, request, cq));
    }
    // long RightUp()
    virtual ::grpc::Status RightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncRightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncRightUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncRightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncRightUpRaw(context, request, cq));
    }
    // long FindMulColor(x1, y1, x2, y2, color, sim)
    virtual ::grpc::Status FindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncFindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncFindMulColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncFindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncFindMulColorRaw(context, request, cq));
    }
    // long FindMultiColor(x1, y1, x2, y2,first_color,offset_color,sim, dir,int32X,int32Y)
    virtual ::grpc::Status FindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::dmsoftRpc::FindMultiColorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::FindMultiColorResponse>> AsyncFindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::FindMultiColorResponse>>(AsyncFindMultiColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::FindMultiColorResponse>> PrepareAsyncFindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::FindMultiColorResponse>>(PrepareAsyncFindMultiColorRaw(context, request, cq));
    }
    // long FindPic(x1, y1, x2, y2, pic_name, delta_color,sim, dir,int32X, int32Y)
    virtual ::grpc::Status FindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncFindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncFindPicRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncFindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncFindPicRaw(context, request, cq));
    }
    // string GetColor(x,y)
    virtual ::grpc::Status GetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::dmsoftRpc::StringResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>> AsyncGetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>>(AsyncGetColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>> PrepareAsyncGetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>>(PrepareAsyncGetColorRaw(context, request, cq));
    }
    // long Reg(reg_code,ver_info)
    virtual ::grpc::Status Reg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncReg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncRegRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncReg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncRegRaw(context, request, cq));
    }
    // long SetPath(path)
    virtual ::grpc::Status SetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncSetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncSetPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncSetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncSetPathRaw(context, request, cq));
    }
    // long BindWindowEx(hwnd,display,mouse,keypad,public,mode)
    virtual ::grpc::Status BindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncBindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncBindWindowExRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncBindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncBindWindowExRaw(context, request, cq));
    }
    // long DownCpu(type,rate)
    virtual ::grpc::Status DownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncDownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncDownCpuRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncDownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncDownCpuRaw(context, request, cq));
    }
    // long EnableBind(enable)
    virtual ::grpc::Status EnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncEnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncEnableBindRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncEnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncEnableBindRaw(context, request, cq));
    }
    // long IsBind(hwnd)
    virtual ::grpc::Status IsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncIsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncIsBindRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncIsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncIsBindRaw(context, request, cq));
    }
    // long LockInput(lock)
    virtual ::grpc::Status LockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncLockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncLockInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLockInputRaw(context, request, cq));
    }
    // long UnBindWindow()
    virtual ::grpc::Status UnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncUnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncUnBindWindowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncUnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncUnBindWindowRaw(context, request, cq));
    }
    // long MoveWindow(hwnd,x,y) 
    virtual ::grpc::Status MoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncMoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncMoveWindowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncMoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncMoveWindowRaw(context, request, cq));
    }
    // long SetClientSize(hwnd,width,height) 
    virtual ::grpc::Status SetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncSetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncSetClientSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncSetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncSetClientSizeRaw(context, request, cq));
    }
    // long SetWindowSize(hwnd,width,height) 
    virtual ::grpc::Status SetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncSetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncSetWindowSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncSetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncSetWindowSizeRaw(context, request, cq));
    }
    // long SetWindowText(hwnd,title) 
    virtual ::grpc::Status SetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::dmsoftRpc::IsOkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> AsyncSetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(AsyncSetWindowTextRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>> PrepareAsyncSetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncSetWindowTextRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::GetDmIndexResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::GetDmIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 归还dm
      virtual void ReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Ver(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::VerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Ver(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::VerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long GetCursorPos(x,y)
      virtual void GetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::PointResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::PointResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long KeyDown(vk_code)
      virtual void KeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long KeyDownChar(key_str)
      virtual void KeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long KeyPress(vk_code)
      virtual void KeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long KeyUp(vk_code)
      virtual void KeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long LeftClick()
      virtual void LeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long LeftDoubleClick()
      virtual void LeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long LeftDown()
      virtual void LeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long LeftUp()
      virtual void LeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long MoveR(rx,ry)
      virtual void MoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long MoveTo(x,y)
      virtual void MoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // string MoveToEx(x,y,w,h)
      virtual void MoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest* request, ::dmsoftRpc::StringResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest* request, ::dmsoftRpc::StringResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long RightClick()
      virtual void RightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long RightDown()
      virtual void RightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long RightUp()
      virtual void RightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long FindMulColor(x1, y1, x2, y2, color, sim)
      virtual void FindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long FindMultiColor(x1, y1, x2, y2,first_color,offset_color,sim, dir,int32X,int32Y)
      virtual void FindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest* request, ::dmsoftRpc::FindMultiColorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest* request, ::dmsoftRpc::FindMultiColorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long FindPic(x1, y1, x2, y2, pic_name, delta_color,sim, dir,int32X, int32Y)
      virtual void FindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // string GetColor(x,y)
      virtual void GetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::StringResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::StringResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long Reg(reg_code,ver_info)
      virtual void Reg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Reg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long SetPath(path)
      virtual void SetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long BindWindowEx(hwnd,display,mouse,keypad,public,mode)
      virtual void BindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long DownCpu(type,rate)
      virtual void DownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long EnableBind(enable)
      virtual void EnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long IsBind(hwnd)
      virtual void IsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long LockInput(lock)
      virtual void LockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long UnBindWindow()
      virtual void UnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long MoveWindow(hwnd,x,y) 
      virtual void MoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long SetClientSize(hwnd,width,height) 
      virtual void SetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long SetWindowSize(hwnd,width,height) 
      virtual void SetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // long SetWindowText(hwnd,title) 
      virtual void SetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::GetDmIndexResponse>* AsyncGetDmIndexRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::GetDmIndexResponse>* PrepareAsyncGetDmIndexRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncReturnDmIndexRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncReturnDmIndexRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::VerResponse>* AsyncVerRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::VerResponse>* PrepareAsyncVerRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::PointResponse>* AsyncGetCursorPosRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::PointResponse>* PrepareAsyncGetCursorPosRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncKeyDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncKeyDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncKeyDownCharRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncKeyDownCharRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncKeyPressRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncKeyPressRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncKeyUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncKeyUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncLeftClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLeftClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncLeftDoubleClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLeftDoubleClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncLeftDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLeftDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncLeftUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLeftUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncMoveRRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncMoveRRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncMoveToRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncMoveToRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>* AsyncMoveToExRaw(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>* PrepareAsyncMoveToExRaw(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncRightClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncRightClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncRightDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncRightDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncRightUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncRightUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncFindMulColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncFindMulColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::FindMultiColorResponse>* AsyncFindMultiColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::FindMultiColorResponse>* PrepareAsyncFindMultiColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncFindPicRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncFindPicRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>* AsyncGetColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::StringResponse>* PrepareAsyncGetColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncRegRaw(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncRegRaw(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncSetPathRaw(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncSetPathRaw(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncBindWindowExRaw(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncBindWindowExRaw(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncDownCpuRaw(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncDownCpuRaw(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncEnableBindRaw(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncEnableBindRaw(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncIsBindRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncIsBindRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncLockInputRaw(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLockInputRaw(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncUnBindWindowRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncUnBindWindowRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncMoveWindowRaw(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncMoveWindowRaw(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncSetClientSizeRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncSetClientSizeRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncSetWindowSizeRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncSetWindowSizeRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* AsyncSetWindowTextRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dmsoftRpc::IsOkResponse>* PrepareAsyncSetWindowTextRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::GetDmIndexResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::GetDmIndexResponse>> AsyncGetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::GetDmIndexResponse>>(AsyncGetDmIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::GetDmIndexResponse>> PrepareAsyncGetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::GetDmIndexResponse>>(PrepareAsyncGetDmIndexRaw(context, request, cq));
    }
    ::grpc::Status ReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncReturnDmIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncReturnDmIndexRaw(context, request, cq));
    }
    ::grpc::Status Ver(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::VerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::VerResponse>> AsyncVer(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::VerResponse>>(AsyncVerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::VerResponse>> PrepareAsyncVer(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::VerResponse>>(PrepareAsyncVerRaw(context, request, cq));
    }
    ::grpc::Status GetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::PointResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::PointResponse>> AsyncGetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::PointResponse>>(AsyncGetCursorPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::PointResponse>> PrepareAsyncGetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::PointResponse>>(PrepareAsyncGetCursorPosRaw(context, request, cq));
    }
    ::grpc::Status KeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncKeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncKeyDownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncKeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncKeyDownRaw(context, request, cq));
    }
    ::grpc::Status KeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncKeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncKeyDownCharRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncKeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncKeyDownCharRaw(context, request, cq));
    }
    ::grpc::Status KeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncKeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncKeyPressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncKeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncKeyPressRaw(context, request, cq));
    }
    ::grpc::Status KeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncKeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncKeyUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncKeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncKeyUpRaw(context, request, cq));
    }
    ::grpc::Status LeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncLeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncLeftClickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLeftClickRaw(context, request, cq));
    }
    ::grpc::Status LeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncLeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncLeftDoubleClickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLeftDoubleClickRaw(context, request, cq));
    }
    ::grpc::Status LeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncLeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncLeftDownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLeftDownRaw(context, request, cq));
    }
    ::grpc::Status LeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncLeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncLeftUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLeftUpRaw(context, request, cq));
    }
    ::grpc::Status MoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncMoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncMoveRRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncMoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncMoveRRaw(context, request, cq));
    }
    ::grpc::Status MoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncMoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncMoveToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncMoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncMoveToRaw(context, request, cq));
    }
    ::grpc::Status MoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::dmsoftRpc::StringResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>> AsyncMoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>>(AsyncMoveToExRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>> PrepareAsyncMoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>>(PrepareAsyncMoveToExRaw(context, request, cq));
    }
    ::grpc::Status RightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncRightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncRightClickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncRightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncRightClickRaw(context, request, cq));
    }
    ::grpc::Status RightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncRightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncRightDownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncRightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncRightDownRaw(context, request, cq));
    }
    ::grpc::Status RightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncRightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncRightUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncRightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncRightUpRaw(context, request, cq));
    }
    ::grpc::Status FindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncFindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncFindMulColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncFindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncFindMulColorRaw(context, request, cq));
    }
    ::grpc::Status FindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::dmsoftRpc::FindMultiColorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::FindMultiColorResponse>> AsyncFindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::FindMultiColorResponse>>(AsyncFindMultiColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::FindMultiColorResponse>> PrepareAsyncFindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::FindMultiColorResponse>>(PrepareAsyncFindMultiColorRaw(context, request, cq));
    }
    ::grpc::Status FindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncFindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncFindPicRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncFindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncFindPicRaw(context, request, cq));
    }
    ::grpc::Status GetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::dmsoftRpc::StringResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>> AsyncGetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>>(AsyncGetColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>> PrepareAsyncGetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>>(PrepareAsyncGetColorRaw(context, request, cq));
    }
    ::grpc::Status Reg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncReg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncRegRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncReg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncRegRaw(context, request, cq));
    }
    ::grpc::Status SetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncSetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncSetPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncSetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncSetPathRaw(context, request, cq));
    }
    ::grpc::Status BindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncBindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncBindWindowExRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncBindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncBindWindowExRaw(context, request, cq));
    }
    ::grpc::Status DownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncDownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncDownCpuRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncDownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncDownCpuRaw(context, request, cq));
    }
    ::grpc::Status EnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncEnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncEnableBindRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncEnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncEnableBindRaw(context, request, cq));
    }
    ::grpc::Status IsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncIsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncIsBindRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncIsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncIsBindRaw(context, request, cq));
    }
    ::grpc::Status LockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncLockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncLockInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncLockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncLockInputRaw(context, request, cq));
    }
    ::grpc::Status UnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncUnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncUnBindWindowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncUnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncUnBindWindowRaw(context, request, cq));
    }
    ::grpc::Status MoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncMoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncMoveWindowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncMoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncMoveWindowRaw(context, request, cq));
    }
    ::grpc::Status SetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncSetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncSetClientSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncSetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncSetClientSizeRaw(context, request, cq));
    }
    ::grpc::Status SetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncSetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncSetWindowSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncSetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncSetWindowSizeRaw(context, request, cq));
    }
    ::grpc::Status SetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::dmsoftRpc::IsOkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> AsyncSetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(AsyncSetWindowTextRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>> PrepareAsyncSetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>>(PrepareAsyncSetWindowTextRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::GetDmIndexResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::GetDmIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void ReturnDmIndex(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Ver(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::VerResponse* response, std::function<void(::grpc::Status)>) override;
      void Ver(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::VerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::PointResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCursorPos(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::PointResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void KeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void KeyDown(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void KeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void KeyDownChar(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void KeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void KeyPress(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void KeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void KeyUp(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void LeftClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void LeftDoubleClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void LeftDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void LeftUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void MoveR(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void MoveTo(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest* request, ::dmsoftRpc::StringResponse* response, std::function<void(::grpc::Status)>) override;
      void MoveToEx(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest* request, ::dmsoftRpc::StringResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void RightClick(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void RightDown(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void RightUp(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void FindMulColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest* request, ::dmsoftRpc::FindMultiColorResponse* response, std::function<void(::grpc::Status)>) override;
      void FindMultiColor(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest* request, ::dmsoftRpc::FindMultiColorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void FindPic(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::StringResponse* response, std::function<void(::grpc::Status)>) override;
      void GetColor(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::StringResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Reg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void Reg(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void SetPath(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void BindWindowEx(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void DownCpu(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableBind(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void IsBind(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void LockInput(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void UnBindWindow(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void MoveWindow(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void SetClientSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void SetWindowSize(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest* request, ::dmsoftRpc::IsOkResponse* response, std::function<void(::grpc::Status)>) override;
      void SetWindowText(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest* request, ::dmsoftRpc::IsOkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::GetDmIndexResponse>* AsyncGetDmIndexRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::GetDmIndexResponse>* PrepareAsyncGetDmIndexRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncReturnDmIndexRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncReturnDmIndexRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::VerResponse>* AsyncVerRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::VerResponse>* PrepareAsyncVerRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::PointResponse>* AsyncGetCursorPosRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::PointResponse>* PrepareAsyncGetCursorPosRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncKeyDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncKeyDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncKeyDownCharRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncKeyDownCharRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyDownCharRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncKeyPressRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncKeyPressRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyPressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncKeyUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncKeyUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::KeyUpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncLeftClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLeftClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncLeftDoubleClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLeftDoubleClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncLeftDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLeftDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncLeftUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLeftUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncMoveRRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncMoveRRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncMoveToRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncMoveToRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>* AsyncMoveToExRaw(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>* PrepareAsyncMoveToExRaw(::grpc::ClientContext* context, const ::dmsoftRpc::RectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncRightClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncRightClickRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncRightDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncRightDownRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncRightUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncRightUpRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncFindMulColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncFindMulColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::FindMultiColorResponse>* AsyncFindMultiColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::FindMultiColorResponse>* PrepareAsyncFindMultiColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindMultiColorExRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncFindPicRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncFindPicRaw(::grpc::ClientContext* context, const ::dmsoftRpc::FindPicRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>* AsyncGetColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::StringResponse>* PrepareAsyncGetColorRaw(::grpc::ClientContext* context, const ::dmsoftRpc::PointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncRegRaw(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncRegRaw(::grpc::ClientContext* context, const ::dmsoftRpc::RegRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncSetPathRaw(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncSetPathRaw(::grpc::ClientContext* context, const ::dmsoftRpc::StringRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncBindWindowExRaw(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncBindWindowExRaw(::grpc::ClientContext* context, const ::dmsoftRpc::BindWindowExRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncDownCpuRaw(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncDownCpuRaw(::grpc::ClientContext* context, const ::dmsoftRpc::DownCpuRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncEnableBindRaw(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncEnableBindRaw(::grpc::ClientContext* context, const ::dmsoftRpc::EnableBindRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncIsBindRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncIsBindRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IsBindRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncLockInputRaw(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncLockInputRaw(::grpc::ClientContext* context, const ::dmsoftRpc::LockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncUnBindWindowRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncUnBindWindowRaw(::grpc::ClientContext* context, const ::dmsoftRpc::IndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncMoveWindowRaw(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncMoveWindowRaw(::grpc::ClientContext* context, const ::dmsoftRpc::MoveWindowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncSetClientSizeRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncSetClientSizeRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetClientSizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncSetWindowSizeRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncSetWindowSizeRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowSizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* AsyncSetWindowTextRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dmsoftRpc::IsOkResponse>* PrepareAsyncSetWindowTextRaw(::grpc::ClientContext* context, const ::dmsoftRpc::SetWindowTextRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetDmIndex_;
    const ::grpc::internal::RpcMethod rpcmethod_ReturnDmIndex_;
    const ::grpc::internal::RpcMethod rpcmethod_Ver_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCursorPos_;
    const ::grpc::internal::RpcMethod rpcmethod_KeyDown_;
    const ::grpc::internal::RpcMethod rpcmethod_KeyDownChar_;
    const ::grpc::internal::RpcMethod rpcmethod_KeyPress_;
    const ::grpc::internal::RpcMethod rpcmethod_KeyUp_;
    const ::grpc::internal::RpcMethod rpcmethod_LeftClick_;
    const ::grpc::internal::RpcMethod rpcmethod_LeftDoubleClick_;
    const ::grpc::internal::RpcMethod rpcmethod_LeftDown_;
    const ::grpc::internal::RpcMethod rpcmethod_LeftUp_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveR_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveTo_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveToEx_;
    const ::grpc::internal::RpcMethod rpcmethod_RightClick_;
    const ::grpc::internal::RpcMethod rpcmethod_RightDown_;
    const ::grpc::internal::RpcMethod rpcmethod_RightUp_;
    const ::grpc::internal::RpcMethod rpcmethod_FindMulColor_;
    const ::grpc::internal::RpcMethod rpcmethod_FindMultiColor_;
    const ::grpc::internal::RpcMethod rpcmethod_FindPic_;
    const ::grpc::internal::RpcMethod rpcmethod_GetColor_;
    const ::grpc::internal::RpcMethod rpcmethod_Reg_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPath_;
    const ::grpc::internal::RpcMethod rpcmethod_BindWindowEx_;
    const ::grpc::internal::RpcMethod rpcmethod_DownCpu_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableBind_;
    const ::grpc::internal::RpcMethod rpcmethod_IsBind_;
    const ::grpc::internal::RpcMethod rpcmethod_LockInput_;
    const ::grpc::internal::RpcMethod rpcmethod_UnBindWindow_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveWindow_;
    const ::grpc::internal::RpcMethod rpcmethod_SetClientSize_;
    const ::grpc::internal::RpcMethod rpcmethod_SetWindowSize_;
    const ::grpc::internal::RpcMethod rpcmethod_SetWindowText_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetDmIndex(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::GetDmIndexResponse* response);
    // 归还dm
    virtual ::grpc::Status ReturnDmIndex(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response);
    virtual ::grpc::Status Ver(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::VerResponse* response);
    // long GetCursorPos(x,y)
    virtual ::grpc::Status GetCursorPos(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::PointResponse* response);
    // long KeyDown(vk_code)
    virtual ::grpc::Status KeyDown(::grpc::ServerContext* context, const ::dmsoftRpc::KeyDownRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long KeyDownChar(key_str)
    virtual ::grpc::Status KeyDownChar(::grpc::ServerContext* context, const ::dmsoftRpc::KeyDownCharRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long KeyPress(vk_code)
    virtual ::grpc::Status KeyPress(::grpc::ServerContext* context, const ::dmsoftRpc::KeyPressRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long KeyUp(vk_code)
    virtual ::grpc::Status KeyUp(::grpc::ServerContext* context, const ::dmsoftRpc::KeyUpRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long LeftClick()
    virtual ::grpc::Status LeftClick(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long LeftDoubleClick()
    virtual ::grpc::Status LeftDoubleClick(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long LeftDown()
    virtual ::grpc::Status LeftDown(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long LeftUp()
    virtual ::grpc::Status LeftUp(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long MoveR(rx,ry)
    virtual ::grpc::Status MoveR(::grpc::ServerContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long MoveTo(x,y)
    virtual ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // string MoveToEx(x,y,w,h)
    virtual ::grpc::Status MoveToEx(::grpc::ServerContext* context, const ::dmsoftRpc::RectRequest* request, ::dmsoftRpc::StringResponse* response);
    // long RightClick()
    virtual ::grpc::Status RightClick(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long RightDown()
    virtual ::grpc::Status RightDown(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long RightUp()
    virtual ::grpc::Status RightUp(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long FindMulColor(x1, y1, x2, y2, color, sim)
    virtual ::grpc::Status FindMulColor(::grpc::ServerContext* context, const ::dmsoftRpc::FindMultiColorRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long FindMultiColor(x1, y1, x2, y2,first_color,offset_color,sim, dir,int32X,int32Y)
    virtual ::grpc::Status FindMultiColor(::grpc::ServerContext* context, const ::dmsoftRpc::FindMultiColorExRequest* request, ::dmsoftRpc::FindMultiColorResponse* response);
    // long FindPic(x1, y1, x2, y2, pic_name, delta_color,sim, dir,int32X, int32Y)
    virtual ::grpc::Status FindPic(::grpc::ServerContext* context, const ::dmsoftRpc::FindPicRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // string GetColor(x,y)
    virtual ::grpc::Status GetColor(::grpc::ServerContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::StringResponse* response);
    // long Reg(reg_code,ver_info)
    virtual ::grpc::Status Reg(::grpc::ServerContext* context, const ::dmsoftRpc::RegRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long SetPath(path)
    virtual ::grpc::Status SetPath(::grpc::ServerContext* context, const ::dmsoftRpc::StringRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long BindWindowEx(hwnd,display,mouse,keypad,public,mode)
    virtual ::grpc::Status BindWindowEx(::grpc::ServerContext* context, const ::dmsoftRpc::BindWindowExRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long DownCpu(type,rate)
    virtual ::grpc::Status DownCpu(::grpc::ServerContext* context, const ::dmsoftRpc::DownCpuRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long EnableBind(enable)
    virtual ::grpc::Status EnableBind(::grpc::ServerContext* context, const ::dmsoftRpc::EnableBindRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long IsBind(hwnd)
    virtual ::grpc::Status IsBind(::grpc::ServerContext* context, const ::dmsoftRpc::IsBindRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long LockInput(lock)
    virtual ::grpc::Status LockInput(::grpc::ServerContext* context, const ::dmsoftRpc::LockRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long UnBindWindow()
    virtual ::grpc::Status UnBindWindow(::grpc::ServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long MoveWindow(hwnd,x,y) 
    virtual ::grpc::Status MoveWindow(::grpc::ServerContext* context, const ::dmsoftRpc::MoveWindowRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long SetClientSize(hwnd,width,height) 
    virtual ::grpc::Status SetClientSize(::grpc::ServerContext* context, const ::dmsoftRpc::SetClientSizeRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long SetWindowSize(hwnd,width,height) 
    virtual ::grpc::Status SetWindowSize(::grpc::ServerContext* context, const ::dmsoftRpc::SetWindowSizeRequest* request, ::dmsoftRpc::IsOkResponse* response);
    // long SetWindowText(hwnd,title) 
    virtual ::grpc::Status SetWindowText(::grpc::ServerContext* context, const ::dmsoftRpc::SetWindowTextRequest* request, ::dmsoftRpc::IsOkResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDmIndex() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::GetDmIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDmIndex(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::GetDmIndexResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReturnDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReturnDmIndex() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ReturnDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReturnDmIndex(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Ver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ver() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Ver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ver(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::VerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVer(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::VerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCursorPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCursorPos() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetCursorPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCursorPos(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::PointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCursorPos(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::PointResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KeyDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KeyDown() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_KeyDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyDown(::grpc::ServerContext* context, ::dmsoftRpc::KeyDownRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KeyDownChar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KeyDownChar() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_KeyDownChar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDownChar(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownCharRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyDownChar(::grpc::ServerContext* context, ::dmsoftRpc::KeyDownCharRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KeyPress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KeyPress() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_KeyPress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyPress(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyPressRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyPress(::grpc::ServerContext* context, ::dmsoftRpc::KeyPressRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KeyUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KeyUp() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_KeyUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyUpRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyUp(::grpc::ServerContext* context, ::dmsoftRpc::KeyUpRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeftClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeftClick() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_LeftClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftClick(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeftDoubleClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeftDoubleClick() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_LeftDoubleClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDoubleClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftDoubleClick(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeftDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeftDown() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_LeftDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftDown(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeftUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeftUp() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_LeftUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftUp(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveR : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveR() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_MoveR() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveR(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveR(::grpc::ServerContext* context, ::dmsoftRpc::PointRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveTo() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTo(::grpc::ServerContext* context, ::dmsoftRpc::PointRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveToEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveToEx() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_MoveToEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveToEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RectRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveToEx(::grpc::ServerContext* context, ::dmsoftRpc::RectRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::StringResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RightClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RightClick() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_RightClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRightClick(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RightDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RightDown() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_RightDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRightDown(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RightUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RightUp() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_RightUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRightUp(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FindMulColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FindMulColor() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_FindMulColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMulColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindMulColor(::grpc::ServerContext* context, ::dmsoftRpc::FindMultiColorRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FindMultiColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FindMultiColor() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_FindMultiColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMultiColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorExRequest* /*request*/, ::dmsoftRpc::FindMultiColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindMultiColor(::grpc::ServerContext* context, ::dmsoftRpc::FindMultiColorExRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::FindMultiColorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FindPic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FindPic() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_FindPic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindPic(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindPicRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindPic(::grpc::ServerContext* context, ::dmsoftRpc::FindPicRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetColor() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetColor(::grpc::ServerContext* context, ::dmsoftRpc::PointRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::StringResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Reg() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_Reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reg(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RegRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReg(::grpc::ServerContext* context, ::dmsoftRpc::RegRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPath() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_SetPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPath(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::StringRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPath(::grpc::ServerContext* context, ::dmsoftRpc::StringRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BindWindowEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BindWindowEx() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_BindWindowEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindWindowEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::BindWindowExRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBindWindowEx(::grpc::ServerContext* context, ::dmsoftRpc::BindWindowExRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownCpu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DownCpu() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_DownCpu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownCpu(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::DownCpuRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownCpu(::grpc::ServerContext* context, ::dmsoftRpc::DownCpuRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableBind() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_EnableBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::EnableBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBind(::grpc::ServerContext* context, ::dmsoftRpc::EnableBindRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsBind() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_IsBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IsBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsBind(::grpc::ServerContext* context, ::dmsoftRpc::IsBindRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LockInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LockInput() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_LockInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockInput(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::LockRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLockInput(::grpc::ServerContext* context, ::dmsoftRpc::LockRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnBindWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnBindWindow() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_UnBindWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBindWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnBindWindow(::grpc::ServerContext* context, ::dmsoftRpc::IndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveWindow() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_MoveWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::MoveWindowRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveWindow(::grpc::ServerContext* context, ::dmsoftRpc::MoveWindowRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetClientSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetClientSize() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_SetClientSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetClientSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetClientSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetClientSize(::grpc::ServerContext* context, ::dmsoftRpc::SetClientSizeRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetWindowSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetWindowSize() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_SetWindowSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetWindowSize(::grpc::ServerContext* context, ::dmsoftRpc::SetWindowSizeRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetWindowText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetWindowText() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_SetWindowText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowText(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowTextRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetWindowText(::grpc::ServerContext* context, ::dmsoftRpc::SetWindowTextRequest* request, ::grpc::ServerAsyncResponseWriter< ::dmsoftRpc::IsOkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetDmIndex<WithAsyncMethod_ReturnDmIndex<WithAsyncMethod_Ver<WithAsyncMethod_GetCursorPos<WithAsyncMethod_KeyDown<WithAsyncMethod_KeyDownChar<WithAsyncMethod_KeyPress<WithAsyncMethod_KeyUp<WithAsyncMethod_LeftClick<WithAsyncMethod_LeftDoubleClick<WithAsyncMethod_LeftDown<WithAsyncMethod_LeftUp<WithAsyncMethod_MoveR<WithAsyncMethod_MoveTo<WithAsyncMethod_MoveToEx<WithAsyncMethod_RightClick<WithAsyncMethod_RightDown<WithAsyncMethod_RightUp<WithAsyncMethod_FindMulColor<WithAsyncMethod_FindMultiColor<WithAsyncMethod_FindPic<WithAsyncMethod_GetColor<WithAsyncMethod_Reg<WithAsyncMethod_SetPath<WithAsyncMethod_BindWindowEx<WithAsyncMethod_DownCpu<WithAsyncMethod_EnableBind<WithAsyncMethod_IsBind<WithAsyncMethod_LockInput<WithAsyncMethod_UnBindWindow<WithAsyncMethod_MoveWindow<WithAsyncMethod_SetClientSize<WithAsyncMethod_SetWindowSize<WithAsyncMethod_SetWindowText<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDmIndex() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::GetDmIndexResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::GetDmIndexResponse* response) { return this->GetDmIndex(context, request, response); }));}
    void SetMessageAllocatorFor_GetDmIndex(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::GetDmIndexResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::GetDmIndexResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::GetDmIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDmIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::GetDmIndexResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReturnDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReturnDmIndex() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->ReturnDmIndex(context, request, response); }));}
    void SetMessageAllocatorFor_ReturnDmIndex(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReturnDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReturnDmIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Ver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Ver() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::VerResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::VerResponse* response) { return this->Ver(context, request, response); }));}
    void SetMessageAllocatorFor_Ver(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::VerResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::VerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Ver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ver(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::VerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ver(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::VerResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCursorPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCursorPos() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::PointResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::PointResponse* response) { return this->GetCursorPos(context, request, response); }));}
    void SetMessageAllocatorFor_GetCursorPos(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::PointResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::PointResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCursorPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCursorPos(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::PointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCursorPos(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::PointResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_KeyDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_KeyDown() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::KeyDownRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::KeyDownRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->KeyDown(context, request, response); }));}
    void SetMessageAllocatorFor_KeyDown(
        ::grpc::MessageAllocator< ::dmsoftRpc::KeyDownRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::KeyDownRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_KeyDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyDown(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::KeyDownRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_KeyDownChar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_KeyDownChar() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::KeyDownCharRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::KeyDownCharRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->KeyDownChar(context, request, response); }));}
    void SetMessageAllocatorFor_KeyDownChar(
        ::grpc::MessageAllocator< ::dmsoftRpc::KeyDownCharRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::KeyDownCharRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_KeyDownChar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDownChar(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownCharRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyDownChar(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::KeyDownCharRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_KeyPress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_KeyPress() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::KeyPressRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::KeyPressRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->KeyPress(context, request, response); }));}
    void SetMessageAllocatorFor_KeyPress(
        ::grpc::MessageAllocator< ::dmsoftRpc::KeyPressRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::KeyPressRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_KeyPress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyPress(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyPressRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyPress(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::KeyPressRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_KeyUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_KeyUp() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::KeyUpRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::KeyUpRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->KeyUp(context, request, response); }));}
    void SetMessageAllocatorFor_KeyUp(
        ::grpc::MessageAllocator< ::dmsoftRpc::KeyUpRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::KeyUpRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_KeyUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyUpRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyUp(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::KeyUpRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LeftClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LeftClick() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->LeftClick(context, request, response); }));}
    void SetMessageAllocatorFor_LeftClick(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LeftClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LeftClick(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LeftDoubleClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LeftDoubleClick() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->LeftDoubleClick(context, request, response); }));}
    void SetMessageAllocatorFor_LeftDoubleClick(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LeftDoubleClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDoubleClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LeftDoubleClick(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LeftDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LeftDown() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->LeftDown(context, request, response); }));}
    void SetMessageAllocatorFor_LeftDown(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LeftDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LeftDown(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LeftUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LeftUp() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->LeftUp(context, request, response); }));}
    void SetMessageAllocatorFor_LeftUp(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LeftUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LeftUp(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveR : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveR() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->MoveR(context, request, response); }));}
    void SetMessageAllocatorFor_MoveR(
        ::grpc::MessageAllocator< ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveR() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveR(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveR(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveTo() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->MoveTo(context, request, response); }));}
    void SetMessageAllocatorFor_MoveTo(
        ::grpc::MessageAllocator< ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTo(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveToEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveToEx() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::RectRequest, ::dmsoftRpc::StringResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::RectRequest* request, ::dmsoftRpc::StringResponse* response) { return this->MoveToEx(context, request, response); }));}
    void SetMessageAllocatorFor_MoveToEx(
        ::grpc::MessageAllocator< ::dmsoftRpc::RectRequest, ::dmsoftRpc::StringResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::RectRequest, ::dmsoftRpc::StringResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveToEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveToEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RectRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveToEx(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::RectRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RightClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RightClick() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->RightClick(context, request, response); }));}
    void SetMessageAllocatorFor_RightClick(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RightClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RightClick(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RightDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RightDown() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->RightDown(context, request, response); }));}
    void SetMessageAllocatorFor_RightDown(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RightDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RightDown(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RightUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RightUp() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->RightUp(context, request, response); }));}
    void SetMessageAllocatorFor_RightUp(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RightUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RightUp(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FindMulColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FindMulColor() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::FindMultiColorRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::FindMultiColorRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->FindMulColor(context, request, response); }));}
    void SetMessageAllocatorFor_FindMulColor(
        ::grpc::MessageAllocator< ::dmsoftRpc::FindMultiColorRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::FindMultiColorRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FindMulColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMulColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FindMulColor(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FindMultiColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FindMultiColor() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::FindMultiColorExRequest, ::dmsoftRpc::FindMultiColorResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::FindMultiColorExRequest* request, ::dmsoftRpc::FindMultiColorResponse* response) { return this->FindMultiColor(context, request, response); }));}
    void SetMessageAllocatorFor_FindMultiColor(
        ::grpc::MessageAllocator< ::dmsoftRpc::FindMultiColorExRequest, ::dmsoftRpc::FindMultiColorResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::FindMultiColorExRequest, ::dmsoftRpc::FindMultiColorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FindMultiColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMultiColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorExRequest* /*request*/, ::dmsoftRpc::FindMultiColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FindMultiColor(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorExRequest* /*request*/, ::dmsoftRpc::FindMultiColorResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FindPic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FindPic() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::FindPicRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::FindPicRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->FindPic(context, request, response); }));}
    void SetMessageAllocatorFor_FindPic(
        ::grpc::MessageAllocator< ::dmsoftRpc::FindPicRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::FindPicRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FindPic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindPic(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindPicRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FindPic(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::FindPicRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetColor() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::PointRequest, ::dmsoftRpc::StringResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::PointRequest* request, ::dmsoftRpc::StringResponse* response) { return this->GetColor(context, request, response); }));}
    void SetMessageAllocatorFor_GetColor(
        ::grpc::MessageAllocator< ::dmsoftRpc::PointRequest, ::dmsoftRpc::StringResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::PointRequest, ::dmsoftRpc::StringResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetColor(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Reg() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::RegRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::RegRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->Reg(context, request, response); }));}
    void SetMessageAllocatorFor_Reg(
        ::grpc::MessageAllocator< ::dmsoftRpc::RegRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::RegRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reg(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RegRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Reg(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::RegRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetPath() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::StringRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::StringRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->SetPath(context, request, response); }));}
    void SetMessageAllocatorFor_SetPath(
        ::grpc::MessageAllocator< ::dmsoftRpc::StringRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::StringRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPath(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::StringRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPath(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::StringRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BindWindowEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BindWindowEx() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::BindWindowExRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::BindWindowExRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->BindWindowEx(context, request, response); }));}
    void SetMessageAllocatorFor_BindWindowEx(
        ::grpc::MessageAllocator< ::dmsoftRpc::BindWindowExRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::BindWindowExRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BindWindowEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindWindowEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::BindWindowExRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BindWindowEx(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::BindWindowExRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DownCpu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DownCpu() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::DownCpuRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::DownCpuRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->DownCpu(context, request, response); }));}
    void SetMessageAllocatorFor_DownCpu(
        ::grpc::MessageAllocator< ::dmsoftRpc::DownCpuRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::DownCpuRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DownCpu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownCpu(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::DownCpuRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownCpu(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::DownCpuRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EnableBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnableBind() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::EnableBindRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::EnableBindRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->EnableBind(context, request, response); }));}
    void SetMessageAllocatorFor_EnableBind(
        ::grpc::MessageAllocator< ::dmsoftRpc::EnableBindRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::EnableBindRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnableBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::EnableBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBind(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::EnableBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsBind() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IsBindRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IsBindRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->IsBind(context, request, response); }));}
    void SetMessageAllocatorFor_IsBind(
        ::grpc::MessageAllocator< ::dmsoftRpc::IsBindRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IsBindRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IsBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsBind(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IsBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LockInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LockInput() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::LockRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::LockRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->LockInput(context, request, response); }));}
    void SetMessageAllocatorFor_LockInput(
        ::grpc::MessageAllocator< ::dmsoftRpc::LockRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::LockRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LockInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockInput(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::LockRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LockInput(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::LockRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UnBindWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UnBindWindow() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::IndexRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->UnBindWindow(context, request, response); }));}
    void SetMessageAllocatorFor_UnBindWindow(
        ::grpc::MessageAllocator< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UnBindWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBindWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UnBindWindow(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveWindow() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::MoveWindowRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::MoveWindowRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->MoveWindow(context, request, response); }));}
    void SetMessageAllocatorFor_MoveWindow(
        ::grpc::MessageAllocator< ::dmsoftRpc::MoveWindowRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::MoveWindowRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::MoveWindowRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveWindow(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::MoveWindowRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetClientSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetClientSize() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::SetClientSizeRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::SetClientSizeRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->SetClientSize(context, request, response); }));}
    void SetMessageAllocatorFor_SetClientSize(
        ::grpc::MessageAllocator< ::dmsoftRpc::SetClientSizeRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::SetClientSizeRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetClientSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetClientSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetClientSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetClientSize(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::SetClientSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetWindowSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetWindowSize() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::SetWindowSizeRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::SetWindowSizeRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->SetWindowSize(context, request, response); }));}
    void SetMessageAllocatorFor_SetWindowSize(
        ::grpc::MessageAllocator< ::dmsoftRpc::SetWindowSizeRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::SetWindowSizeRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetWindowSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetWindowSize(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::SetWindowSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetWindowText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetWindowText() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::SetWindowTextRequest, ::dmsoftRpc::IsOkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dmsoftRpc::SetWindowTextRequest* request, ::dmsoftRpc::IsOkResponse* response) { return this->SetWindowText(context, request, response); }));}
    void SetMessageAllocatorFor_SetWindowText(
        ::grpc::MessageAllocator< ::dmsoftRpc::SetWindowTextRequest, ::dmsoftRpc::IsOkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dmsoftRpc::SetWindowTextRequest, ::dmsoftRpc::IsOkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetWindowText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowText(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowTextRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetWindowText(
      ::grpc::CallbackServerContext* /*context*/, const ::dmsoftRpc::SetWindowTextRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetDmIndex<WithCallbackMethod_ReturnDmIndex<WithCallbackMethod_Ver<WithCallbackMethod_GetCursorPos<WithCallbackMethod_KeyDown<WithCallbackMethod_KeyDownChar<WithCallbackMethod_KeyPress<WithCallbackMethod_KeyUp<WithCallbackMethod_LeftClick<WithCallbackMethod_LeftDoubleClick<WithCallbackMethod_LeftDown<WithCallbackMethod_LeftUp<WithCallbackMethod_MoveR<WithCallbackMethod_MoveTo<WithCallbackMethod_MoveToEx<WithCallbackMethod_RightClick<WithCallbackMethod_RightDown<WithCallbackMethod_RightUp<WithCallbackMethod_FindMulColor<WithCallbackMethod_FindMultiColor<WithCallbackMethod_FindPic<WithCallbackMethod_GetColor<WithCallbackMethod_Reg<WithCallbackMethod_SetPath<WithCallbackMethod_BindWindowEx<WithCallbackMethod_DownCpu<WithCallbackMethod_EnableBind<WithCallbackMethod_IsBind<WithCallbackMethod_LockInput<WithCallbackMethod_UnBindWindow<WithCallbackMethod_MoveWindow<WithCallbackMethod_SetClientSize<WithCallbackMethod_SetWindowSize<WithCallbackMethod_SetWindowText<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDmIndex() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::GetDmIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReturnDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReturnDmIndex() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ReturnDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Ver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ver() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Ver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ver(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::VerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCursorPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCursorPos() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetCursorPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCursorPos(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::PointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KeyDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KeyDown() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_KeyDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KeyDownChar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KeyDownChar() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_KeyDownChar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDownChar(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownCharRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KeyPress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KeyPress() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_KeyPress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyPress(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyPressRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KeyUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KeyUp() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_KeyUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyUpRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeftClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeftClick() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_LeftClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeftDoubleClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeftDoubleClick() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_LeftDoubleClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDoubleClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeftDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeftDown() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_LeftDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeftUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeftUp() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_LeftUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveR : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveR() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_MoveR() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveR(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveTo() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveToEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveToEx() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_MoveToEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveToEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RectRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RightClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RightClick() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_RightClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RightDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RightDown() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_RightDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RightUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RightUp() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_RightUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FindMulColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FindMulColor() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_FindMulColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMulColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FindMultiColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FindMultiColor() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_FindMultiColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMultiColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorExRequest* /*request*/, ::dmsoftRpc::FindMultiColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FindPic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FindPic() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_FindPic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindPic(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindPicRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetColor() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Reg() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_Reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reg(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RegRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPath() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_SetPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPath(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::StringRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BindWindowEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BindWindowEx() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_BindWindowEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindWindowEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::BindWindowExRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownCpu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DownCpu() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_DownCpu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownCpu(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::DownCpuRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableBind() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_EnableBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::EnableBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsBind() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_IsBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IsBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LockInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LockInput() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_LockInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockInput(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::LockRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnBindWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnBindWindow() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_UnBindWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBindWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveWindow() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_MoveWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::MoveWindowRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetClientSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetClientSize() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_SetClientSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetClientSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetClientSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetWindowSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetWindowSize() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_SetWindowSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetWindowText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetWindowText() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_SetWindowText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowText(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowTextRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDmIndex() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::GetDmIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDmIndex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReturnDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReturnDmIndex() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ReturnDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReturnDmIndex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ver() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Ver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ver(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::VerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCursorPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCursorPos() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetCursorPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCursorPos(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::PointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCursorPos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KeyDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KeyDown() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_KeyDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyDown(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KeyDownChar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KeyDownChar() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_KeyDownChar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDownChar(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownCharRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyDownChar(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KeyPress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KeyPress() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_KeyPress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyPress(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyPressRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyPress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KeyUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KeyUp() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_KeyUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyUpRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyUp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeftClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeftClick() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_LeftClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftClick(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeftDoubleClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeftDoubleClick() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_LeftDoubleClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDoubleClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftDoubleClick(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeftDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeftDown() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_LeftDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftDown(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeftUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeftUp() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_LeftUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftUp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveR : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveR() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_MoveR() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveR(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveR(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveTo() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveToEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveToEx() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_MoveToEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveToEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RectRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveToEx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RightClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RightClick() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_RightClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRightClick(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RightDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RightDown() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_RightDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRightDown(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RightUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RightUp() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_RightUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRightUp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FindMulColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FindMulColor() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_FindMulColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMulColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindMulColor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FindMultiColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FindMultiColor() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_FindMultiColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMultiColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorExRequest* /*request*/, ::dmsoftRpc::FindMultiColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindMultiColor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FindPic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FindPic() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_FindPic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindPic(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindPicRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindPic(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetColor() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetColor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Reg() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_Reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reg(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RegRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPath() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_SetPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPath(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::StringRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPath(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BindWindowEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BindWindowEx() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_BindWindowEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindWindowEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::BindWindowExRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBindWindowEx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownCpu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DownCpu() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_DownCpu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownCpu(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::DownCpuRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownCpu(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableBind() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_EnableBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::EnableBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBind(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsBind() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_IsBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IsBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsBind(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LockInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LockInput() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_LockInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockInput(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::LockRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLockInput(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnBindWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnBindWindow() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_UnBindWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBindWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnBindWindow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveWindow() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_MoveWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::MoveWindowRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveWindow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetClientSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetClientSize() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_SetClientSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetClientSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetClientSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetClientSize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetWindowSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetWindowSize() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_SetWindowSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetWindowSize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetWindowText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetWindowText() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_SetWindowText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowText(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowTextRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetWindowText(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDmIndex() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDmIndex(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::GetDmIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDmIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReturnDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReturnDmIndex() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReturnDmIndex(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReturnDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReturnDmIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Ver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Ver() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ver(context, request, response); }));
    }
    ~WithRawCallbackMethod_Ver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ver(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::VerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ver(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCursorPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCursorPos() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCursorPos(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCursorPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCursorPos(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::PointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCursorPos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_KeyDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_KeyDown() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KeyDown(context, request, response); }));
    }
    ~WithRawCallbackMethod_KeyDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyDown(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_KeyDownChar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_KeyDownChar() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KeyDownChar(context, request, response); }));
    }
    ~WithRawCallbackMethod_KeyDownChar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyDownChar(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownCharRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyDownChar(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_KeyPress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_KeyPress() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KeyPress(context, request, response); }));
    }
    ~WithRawCallbackMethod_KeyPress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyPress(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyPressRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyPress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_KeyUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_KeyUp() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KeyUp(context, request, response); }));
    }
    ~WithRawCallbackMethod_KeyUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyUpRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyUp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LeftClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LeftClick() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeftClick(context, request, response); }));
    }
    ~WithRawCallbackMethod_LeftClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LeftClick(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LeftDoubleClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LeftDoubleClick() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeftDoubleClick(context, request, response); }));
    }
    ~WithRawCallbackMethod_LeftDoubleClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDoubleClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LeftDoubleClick(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LeftDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LeftDown() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeftDown(context, request, response); }));
    }
    ~WithRawCallbackMethod_LeftDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LeftDown(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LeftUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LeftUp() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeftUp(context, request, response); }));
    }
    ~WithRawCallbackMethod_LeftUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LeftUp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveR : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveR() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveR(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveR() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveR(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveR(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveTo() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveTo(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveToEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveToEx() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveToEx(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveToEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveToEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RectRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveToEx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RightClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RightClick() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RightClick(context, request, response); }));
    }
    ~WithRawCallbackMethod_RightClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RightClick(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RightDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RightDown() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RightDown(context, request, response); }));
    }
    ~WithRawCallbackMethod_RightDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RightDown(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RightUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RightUp() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RightUp(context, request, response); }));
    }
    ~WithRawCallbackMethod_RightUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RightUp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FindMulColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FindMulColor() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FindMulColor(context, request, response); }));
    }
    ~WithRawCallbackMethod_FindMulColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMulColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FindMulColor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FindMultiColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FindMultiColor() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FindMultiColor(context, request, response); }));
    }
    ~WithRawCallbackMethod_FindMultiColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMultiColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorExRequest* /*request*/, ::dmsoftRpc::FindMultiColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FindMultiColor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FindPic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FindPic() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FindPic(context, request, response); }));
    }
    ~WithRawCallbackMethod_FindPic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindPic(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindPicRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FindPic(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetColor() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetColor(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetColor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Reg() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Reg(context, request, response); }));
    }
    ~WithRawCallbackMethod_Reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reg(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RegRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Reg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetPath() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPath(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPath(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::StringRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BindWindowEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BindWindowEx() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BindWindowEx(context, request, response); }));
    }
    ~WithRawCallbackMethod_BindWindowEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BindWindowEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::BindWindowExRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BindWindowEx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DownCpu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DownCpu() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DownCpu(context, request, response); }));
    }
    ~WithRawCallbackMethod_DownCpu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownCpu(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::DownCpuRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownCpu(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnableBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnableBind() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableBind(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnableBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::EnableBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBind(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsBind() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsBind(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IsBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsBind(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LockInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LockInput() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LockInput(context, request, response); }));
    }
    ~WithRawCallbackMethod_LockInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockInput(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::LockRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LockInput(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UnBindWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UnBindWindow() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnBindWindow(context, request, response); }));
    }
    ~WithRawCallbackMethod_UnBindWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBindWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UnBindWindow(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveWindow() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveWindow(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::MoveWindowRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveWindow(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetClientSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetClientSize() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetClientSize(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetClientSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetClientSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetClientSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetClientSize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetWindowSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetWindowSize() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetWindowSize(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetWindowSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetWindowSize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetWindowText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetWindowText() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetWindowText(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetWindowText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetWindowText(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowTextRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetWindowText(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDmIndex() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::GetDmIndexResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::GetDmIndexResponse>* streamer) {
                       return this->StreamedGetDmIndex(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::GetDmIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDmIndex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::GetDmIndexResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReturnDmIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReturnDmIndex() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedReturnDmIndex(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReturnDmIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReturnDmIndex(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReturnDmIndex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ver() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::VerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::VerResponse>* streamer) {
                       return this->StreamedVer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ver(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::VerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::VerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCursorPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCursorPos() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::PointResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::PointResponse>* streamer) {
                       return this->StreamedGetCursorPos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCursorPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCursorPos(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::PointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCursorPos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::PointResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KeyDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KeyDown() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::KeyDownRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::KeyDownRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedKeyDown(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KeyDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KeyDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKeyDown(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::KeyDownRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KeyDownChar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KeyDownChar() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::KeyDownCharRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::KeyDownCharRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedKeyDownChar(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KeyDownChar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KeyDownChar(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyDownCharRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKeyDownChar(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::KeyDownCharRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KeyPress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KeyPress() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::KeyPressRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::KeyPressRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedKeyPress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KeyPress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KeyPress(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyPressRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKeyPress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::KeyPressRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KeyUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KeyUp() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::KeyUpRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::KeyUpRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedKeyUp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KeyUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KeyUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::KeyUpRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKeyUp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::KeyUpRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeftClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeftClick() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedLeftClick(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeftClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeftClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeftClick(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeftDoubleClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeftDoubleClick() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedLeftDoubleClick(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeftDoubleClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeftDoubleClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeftDoubleClick(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeftDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeftDown() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedLeftDown(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeftDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeftDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeftDown(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeftUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeftUp() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedLeftUp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeftUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeftUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeftUp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveR : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveR() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedMoveR(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveR() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveR(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveR(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::PointRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveTo() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::PointRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedMoveTo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveTo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::PointRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveToEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveToEx() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::RectRequest, ::dmsoftRpc::StringResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::RectRequest, ::dmsoftRpc::StringResponse>* streamer) {
                       return this->StreamedMoveToEx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveToEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveToEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RectRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveToEx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::RectRequest,::dmsoftRpc::StringResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RightClick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RightClick() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedRightClick(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RightClick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RightClick(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRightClick(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RightDown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RightDown() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedRightDown(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RightDown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RightDown(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRightDown(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RightUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RightUp() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedRightUp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RightUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RightUp(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRightUp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FindMulColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FindMulColor() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::FindMultiColorRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::FindMultiColorRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedFindMulColor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FindMulColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindMulColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFindMulColor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::FindMultiColorRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FindMultiColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FindMultiColor() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::FindMultiColorExRequest, ::dmsoftRpc::FindMultiColorResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::FindMultiColorExRequest, ::dmsoftRpc::FindMultiColorResponse>* streamer) {
                       return this->StreamedFindMultiColor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FindMultiColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindMultiColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindMultiColorExRequest* /*request*/, ::dmsoftRpc::FindMultiColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFindMultiColor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::FindMultiColorExRequest,::dmsoftRpc::FindMultiColorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FindPic : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FindPic() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::FindPicRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::FindPicRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedFindPic(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FindPic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindPic(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::FindPicRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFindPic(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::FindPicRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetColor() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::PointRequest, ::dmsoftRpc::StringResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::PointRequest, ::dmsoftRpc::StringResponse>* streamer) {
                       return this->StreamedGetColor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetColor(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::PointRequest* /*request*/, ::dmsoftRpc::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetColor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::PointRequest,::dmsoftRpc::StringResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Reg() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::RegRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::RegRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedReg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Reg(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::RegRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::RegRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPath() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::StringRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::StringRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedSetPath(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPath(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::StringRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPath(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::StringRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BindWindowEx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BindWindowEx() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::BindWindowExRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::BindWindowExRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedBindWindowEx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BindWindowEx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BindWindowEx(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::BindWindowExRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBindWindowEx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::BindWindowExRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DownCpu : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DownCpu() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::DownCpuRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::DownCpuRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedDownCpu(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DownCpu() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownCpu(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::DownCpuRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDownCpu(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::DownCpuRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableBind() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::EnableBindRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::EnableBindRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedEnableBind(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::EnableBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableBind(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::EnableBindRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsBind : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsBind() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IsBindRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IsBindRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedIsBind(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsBind() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsBind(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IsBindRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsBind(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IsBindRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LockInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LockInput() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::LockRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::LockRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedLockInput(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LockInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LockInput(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::LockRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLockInput(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::LockRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnBindWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnBindWindow() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::IndexRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedUnBindWindow(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnBindWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnBindWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::IndexRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnBindWindow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::IndexRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveWindow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveWindow() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::MoveWindowRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::MoveWindowRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedMoveWindow(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveWindow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveWindow(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::MoveWindowRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveWindow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::MoveWindowRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetClientSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetClientSize() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::SetClientSizeRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::SetClientSizeRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedSetClientSize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetClientSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetClientSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetClientSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetClientSize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::SetClientSizeRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetWindowSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetWindowSize() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::SetWindowSizeRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::SetWindowSizeRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedSetWindowSize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetWindowSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetWindowSize(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowSizeRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetWindowSize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::SetWindowSizeRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetWindowText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetWindowText() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dmsoftRpc::SetWindowTextRequest, ::dmsoftRpc::IsOkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dmsoftRpc::SetWindowTextRequest, ::dmsoftRpc::IsOkResponse>* streamer) {
                       return this->StreamedSetWindowText(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetWindowText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetWindowText(::grpc::ServerContext* /*context*/, const ::dmsoftRpc::SetWindowTextRequest* /*request*/, ::dmsoftRpc::IsOkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetWindowText(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dmsoftRpc::SetWindowTextRequest,::dmsoftRpc::IsOkResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetDmIndex<WithStreamedUnaryMethod_ReturnDmIndex<WithStreamedUnaryMethod_Ver<WithStreamedUnaryMethod_GetCursorPos<WithStreamedUnaryMethod_KeyDown<WithStreamedUnaryMethod_KeyDownChar<WithStreamedUnaryMethod_KeyPress<WithStreamedUnaryMethod_KeyUp<WithStreamedUnaryMethod_LeftClick<WithStreamedUnaryMethod_LeftDoubleClick<WithStreamedUnaryMethod_LeftDown<WithStreamedUnaryMethod_LeftUp<WithStreamedUnaryMethod_MoveR<WithStreamedUnaryMethod_MoveTo<WithStreamedUnaryMethod_MoveToEx<WithStreamedUnaryMethod_RightClick<WithStreamedUnaryMethod_RightDown<WithStreamedUnaryMethod_RightUp<WithStreamedUnaryMethod_FindMulColor<WithStreamedUnaryMethod_FindMultiColor<WithStreamedUnaryMethod_FindPic<WithStreamedUnaryMethod_GetColor<WithStreamedUnaryMethod_Reg<WithStreamedUnaryMethod_SetPath<WithStreamedUnaryMethod_BindWindowEx<WithStreamedUnaryMethod_DownCpu<WithStreamedUnaryMethod_EnableBind<WithStreamedUnaryMethod_IsBind<WithStreamedUnaryMethod_LockInput<WithStreamedUnaryMethod_UnBindWindow<WithStreamedUnaryMethod_MoveWindow<WithStreamedUnaryMethod_SetClientSize<WithStreamedUnaryMethod_SetWindowSize<WithStreamedUnaryMethod_SetWindowText<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetDmIndex<WithStreamedUnaryMethod_ReturnDmIndex<WithStreamedUnaryMethod_Ver<WithStreamedUnaryMethod_GetCursorPos<WithStreamedUnaryMethod_KeyDown<WithStreamedUnaryMethod_KeyDownChar<WithStreamedUnaryMethod_KeyPress<WithStreamedUnaryMethod_KeyUp<WithStreamedUnaryMethod_LeftClick<WithStreamedUnaryMethod_LeftDoubleClick<WithStreamedUnaryMethod_LeftDown<WithStreamedUnaryMethod_LeftUp<WithStreamedUnaryMethod_MoveR<WithStreamedUnaryMethod_MoveTo<WithStreamedUnaryMethod_MoveToEx<WithStreamedUnaryMethod_RightClick<WithStreamedUnaryMethod_RightDown<WithStreamedUnaryMethod_RightUp<WithStreamedUnaryMethod_FindMulColor<WithStreamedUnaryMethod_FindMultiColor<WithStreamedUnaryMethod_FindPic<WithStreamedUnaryMethod_GetColor<WithStreamedUnaryMethod_Reg<WithStreamedUnaryMethod_SetPath<WithStreamedUnaryMethod_BindWindowEx<WithStreamedUnaryMethod_DownCpu<WithStreamedUnaryMethod_EnableBind<WithStreamedUnaryMethod_IsBind<WithStreamedUnaryMethod_LockInput<WithStreamedUnaryMethod_UnBindWindow<WithStreamedUnaryMethod_MoveWindow<WithStreamedUnaryMethod_SetClientSize<WithStreamedUnaryMethod_SetWindowSize<WithStreamedUnaryMethod_SetWindowText<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace dmsoftRpc


#endif  // GRPC_dmsoft_2eproto__INCLUDED
